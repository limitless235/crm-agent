# crack_simulation.py
"""Simulate cracking of hashed passwords.

This placeholder script reads hashed password files generated by `hash_passwords.py`
and attempts to crack them using a simple dictionary attack. If `hashcat` is
installed and the user has GPU resources, it can be invoked for faster cracking.

The script produces a CSV report `crack_results.csv` with columns:
- algorithm
- password_file
- total_hashes
- cracked_hashes
- success_rate
- time_seconds
"""

import os
import csv
import time
import subprocess
from pathlib import Path

HASHED_ROOT = Path(__file__).parent / "hashed"
RESULTS_FILE = Path(__file__).parent / "crack_results.csv"

def simple_dictionary_attack(hash_file: Path, algorithm: str) -> tuple[int, int, float]:
    """Very naive attack: try each password from a small dictionary.
    Returns (total, cracked, duration)."""
    start = time.time()
    # Load a tiny dictionary (could be extended)
    dict_path = Path(__file__).parent / "common_passwords.txt"
    if not dict_path.is_file():
        # fallback small list
        dictionary = ["password", "123456", "admin", "letmein"]
    else:
        with open(dict_path, "r", encoding="utf-8") as f:
            dictionary = [line.strip() for line in f.readlines()]
    total = 0
    cracked = 0
    with open(hash_file, "r", encoding="utf-8") as f:
        hashes = [line.strip() for line in f if line.strip()]
    total = len(hashes)
    # For each hash, compare with dictionary hashes
    for pwd in dictionary:
        # Compute hash using same algorithm
        if algorithm in ["md5", "sha1", "sha256"]:
            import hashlib
            h = getattr(hashlib, algorithm)()
            h.update(pwd.encode())
            candidate = h.hexdigest()
        elif algorithm == "pbkdf2":
            from passlib.hash import pbkdf2_sha256
            candidate = pbkdf2_sha256.hash(pwd)
        elif algorithm == "bcrypt":
            from passlib.hash import bcrypt
            candidate = bcrypt.hash(pwd)
        elif algorithm == "scrypt":
            from passlib.hash import scrypt
            candidate = scrypt.hash(pwd)
        elif algorithm == "argon2":
            from passlib.hash import argon2
            candidate = argon2.hash(pwd)
        else:
            continue
        # Simple match (exact string) – in real case need verification function
        cracked += sum(1 for h in hashes if h == candidate)
    duration = time.time() - start
    return total, cracked, duration

def run_hashcat(hash_file: Path, algorithm: str) -> tuple[int, int, float]:
    """If hashcat is available, invoke it. This is a stub – actual command
    depends on algorithm and hash format. Returns dummy values for now."""
    # Check if hashcat exists
    if not shutil.which("hashcat"):
        return simple_dictionary_attack(hash_file, algorithm)
    # Placeholder: call hashcat with appropriate mode (not implemented)
    # For now just fallback
    return simple_dictionary_attack(hash_file, algorithm)

def main():
    results = []
    for algo_dir in HASHED_ROOT.iterdir():
        if not algo_dir.is_dir():
            continue
        algorithm = algo_dir.name
        for pwd_file in algo_dir.iterdir():
            if not pwd_file.is_file():
                continue
            total, cracked, duration = simple_dictionary_attack(pwd_file, algorithm)
            success = (cracked / total) * 100 if total else 0
            results.append([algorithm, pwd_file.name, total, cracked, f"{success:.2f}", f"{duration:.2f}"])
    # Write CSV
    with open(RESULTS_FILE, "w", newline="", encoding="utf-8") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["algorithm", "password_file", "total_hashes", "cracked_hashes", "success_rate_percent", "time_seconds"])
        writer.writerows(results)
    print(f"Crack simulation completed. Results saved to {RESULTS_FILE}")

if __name__ == "__main__":
    main()
